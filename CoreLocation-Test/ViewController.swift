//
//  ViewController.swift
//  CoreLocation-Test
//
//  Created by C4Q on 1/18/18.
//  Copyright Â© 2018 Melissa He @ C4Q. All rights reserved.
//

import UIKit
import CoreLocation
import MapKit

class ViewController: UIViewController, CLLocationManagerDelegate {

    //we could instantiate the location manager here, but then that would let other classes possibly use this
    @IBOutlet weak var mapView: MKMapView!
    
    var locationManager: CLLocationManager!
    var annotations: [MKAnnotation] = []
    var searchController: UISearchController!
    
    //user location
    var userLocation: CLLocation!

    //making searches in the map view
    var localSearch: MKLocalSearch!
    var localSearchRequest: MKLocalSearchRequest!
    
    override func viewDidLoad() {
        super.viewDidLoad()

        //you can also change the map type
        mapView.mapType = .hybrid
        
        let searchButton = UIBarButtonItem(barButtonSystemItem: .search, target: self, action: #selector(searchButtonAction))
        
        self.navigationItem.rightBarButtonItem = searchButton
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        determineMyLocation()
    }
    
    @IBAction func requestButtonPressed(_ sender: UIBarButtonItem) {
        
        print("button tapped!!")
        
        switch CLLocationManager.authorizationStatus() {
        case .authorizedAlways, .authorizedWhenInUse:
            print("Authorized")
            
            determineMyLocation()
        case .denied, .restricted:
            print("Denied")
            
            //if denied, get the url to the settings app
            guard let validSettingsURL: URL = URL(string: UIApplicationOpenSettingsURLString) else {
                return
            }
            
            //presents an alert controller using the URL?
           
           let alertController = UIAlertController(title: "You must enable location access in the Settings app.", message: nil, preferredStyle: .alert)
            
            let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
            
            let settingsAction = UIAlertAction(title: "Settings", style: .default, handler: { _ in
                
                //makes the settings app open
                UIApplication.shared.open(validSettingsURL, options: [:], completionHandler: nil)
                
            })
            
            alertController.addAction(cancelAction)
            alertController.addAction(settingsAction)
            
            self.present(alertController, animated: true, completion: nil)
            
        case .notDetermined:
            print("Not determined")
           
            //requests authorization - will present alert
            locationManager.requestWhenInUseAuthorization()
        }
    }
    
    func determineMyLocation() {
        
        //these must be instantiated and set every time - order to force the map to move to your location again
        locationManager = CLLocationManager()
        locationManager.delegate = self
        
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        
        //this will prompt your user to give access to the core location in the app
        
        //Best practice, we could use requestAlwaysAuthorization(), which means the app knows where we are even if the app isn't in use, which isn't that good - we want to only use the location if we need it
//        locationManager.requestWhenInUseAuthorization()
        
        //this only runs if the user says yes to location access
        if CLLocationManager.locationServicesEnabled() {
            //starts the generation of updates that report the user's location - we can access this info in the delegate method
            locationManager.startUpdatingLocation()
        }
        
        //if the user says no, you could have an else block that does other stuff
    }
    
    //if the user changes location - you can check with this method
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        //CLLocation - object that contains info about the lat and long of a location, generated by the location manager
        
        //the most recent location will be at the front of the array
        userLocation = locations[0]
        
        print("User Latitude: \(userLocation.coordinate.latitude), User Longitude: \(userLocation.coordinate.longitude)", separator: "\n")
        
        //how do we make the map move to this location?
        //we need to make a region, and the region needs a center (which are the long and lat)
        //1. initialize the center of the region (a coordinate)
        let center = CLLocationCoordinate2D(latitude: userLocation.coordinate.latitude, longitude: userLocation.coordinate.longitude)
        //2. create a mapkit region using the center - if you want the region to be bigger, you can pass in small values
        let region = MKCoordinateRegion(center: center, span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01))
        
        //3. assign the region to the map view
        mapView.setRegion(region, animated: true)
        
        //we can choose to show user location or not
        mapView.showsUserLocation = true
        
        //creating a placemarker and annotation
        //1. create the placemarker
        let userAnnotation = MKPointAnnotation()
        
        //2. give the annotation a coordinate
        userAnnotation.coordinate = center
        
        //3. give the annotation a title!
        userAnnotation.title = "Current Location"
        
        //4. add the annotation to the mapView
//        mapView.addAnnotation(userAnnotation)
        
        //we can have the location manager stop updating after getting a location if you want
//        locationManager.stopUpdatingLocation()
    }

    //if the location manager fails to get the user location (maybe lost connection, etc.)
        //you WILL get an error if you forget to request location access in the plist
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Error: Could not get location. \(error)")
    }
    
    @objc func searchButtonAction() {
        print("Ya did it!!")
        
        //create a search controller
        if searchController == nil {
            searchController = UISearchController(searchResultsController: nil)
        }
        
        self.searchController.hidesNavigationBarDuringPresentation = false
        
        self.searchController.searchBar.delegate = self
//        self.present(searchController, animated: true, completion: nil)
        self.navigationItem.searchController = self.searchController
        self.searchController.dimsBackgroundDuringPresentation = false
    }
    
    
}

extension ViewController: UISearchBarDelegate {
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
//        self.navigationItem.searchController?.dismiss(animated: true, completion: nil)
    
    }
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        searchBar.resignFirstResponder()
        
        //just removes the pins when you do a new search so the pins don't stay on the screen even when you do a new search
        if mapView.annotations.count != 0 {
            annotations = mapView.annotations
            mapView.removeAnnotations(mapView.annotations)
        }
        
        localSearchRequest = MKLocalSearchRequest()
        
        localSearchRequest.naturalLanguageQuery = searchBar.text
        
        //we can also change the search request location to our region location
        localSearchRequest.region = MKCoordinateRegion(center: userLocation.coordinate, span: MKCoordinateSpan(latitudeDelta: 10, longitudeDelta: 10))
        
        //so for the map view app, maybe we can
        
        localSearch = MKLocalSearch(request: localSearchRequest)
        
        //what does weak self do??
        
        localSearch.start { (searchResponse, error) in
            if let error = error {
                print(error)
            }
            
            guard let searchResponse = searchResponse else  {
            
                let alertController = UIAlertController(title: "Place not found", message: "LOL", preferredStyle: .alert)
                
                let alertAction = UIAlertAction(title: "OK", style: .default, handler: nil)
                
                alertController.addAction(alertAction)
                
                
                //for some reason an alert controller already presented lol, so i had to dismiss it
                if self.presentedViewController == nil {
                    self.present(alertController, animated: true, completion: nil)
                } else {
                    self.dismiss(animated: true, completion: {
                        self.present(alertController, animated: true, completion: nil)
                    })
                }
                
                
                return
            }
            
           //once you have the search response, we can get the coordinate center!
            let searchResults: [MKMapItem] = searchResponse.mapItems
            
            //probably need to add just a liiiiittle space for the span because otherwise some pins are partially past the screen
            let searchRegion = MKCoordinateRegion(center: searchResponse.boundingRegion.center, span: MKCoordinateSpan(latitudeDelta: searchResponse.boundingRegion.span.latitudeDelta + 0.01, longitudeDelta: searchResponse.boundingRegion.span.longitudeDelta + 0.01))
            
            self.mapView.setRegion(searchRegion, animated: true)
            
            var mapPinAnnotations: [MKPinAnnotationView] = []
            
            searchResults.forEach {
                
                let pointAnnotation = MKPointAnnotation()
                
                pointAnnotation.coordinate = $0.placemark.coordinate
                
                let mapPin = MKPinAnnotationView(annotation: pointAnnotation, reuseIdentifier: nil)
                
                mapPinAnnotations.append(mapPin)
                
                //with MKPinAnnotationView, I assume you might be able to change more stuff than if you only put MKPointAnnotation (like you can change the pin color)
                
            }
            self.mapView.addAnnotations(mapPinAnnotations.map{$0.annotation!})
            
        }
    }
}
